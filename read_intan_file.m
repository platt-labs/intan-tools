function dat = read_intan_file(file)
% Read a data file generated by the Intan RHD2000 series software

if isnumeric(file)
    fid = file;
else
    fid = fopen(file);
end

% Nested function for reading structured data from fid
    function h = read_structured(h, typeinfo)
        for i=1:size(typeinfo,1)
            num_items = 1;
            type = typeinfo{i,2};
            if iscell(type)
                num_items = type{1};
                type = type{2};
            end
            if strcmpi(type, 'qstring')
                if num_items == 1
                    val = fread_QString(fid);
                else
                    val = cell(1,num_items);
                    for j=1:num_items
                        val{j} = fread_QString(fid);
                    end
                end
            else
                val = fread(fid, num_items, type);
            end
            h.(typeinfo{i,1}) = val;
        end
    end

% Check the magic number at the beginning of the file, but if it
% doesn't match we only need to raise a warning
magic_number = fread(fid, 1, 'uint32');
if magic_number ~= hex2dec('c6912702')
    warning(['Intan file magic number doesn''t match, ' ...
        'this may not be an Intan data file.']);
end

hdr = read_structured(struct, {
    'file_version',                     {2, 'int16'};
    'sample_rate',                      'single';
    'dsp_enabled',                      'int16';
    'actual_dsp_cutoff_frequency',      'single';
    'actual_lower_bandwidth',           'single';
    'actual_upper_bandwidth',           'single';
    'desired_dsp_cutoff_frequency',     'single';
    'desired_lower_bandwidth',          'single';
    'desired_upper_bandwidth',          'single';
    'notch_filter_mode',                'int16';
    'desired_impedance_test_frequency', 'single';
    'actual_impedance_test_frequency',  'single';
    'notes',                            {3, 'qstring'};
    });

sample_rate = hdr.sample_rate;

% Read header info conditionally based on file version numbers
if version_is_at_least(hdr.file_version, [1 1])
    hdr.num_temp_sensor_channels = fread(fid, 1, 'int16');
else
    hdr.num_temp_sensor_channels = 0;
end
if version_is_at_least(hdr.file_version, [1 3])
    hdr.eval_board_mode = fread(fid, 1, 'int16');
else
    hdr.eval_board_mode = 0;
end
if version_is_at_least(hdr.file_version, [2 0])
    hdr.reference_channel = fread_QString(fid);
else
    hdr.reference_channel = '';
end

% Check for notch filtering
if hdr.notch_filter_mode == 1
    notch_filter_frequency = 50;
elseif hdr.notch_filter_mode == 2
    notch_filter_frequency = 60;
else
    notch_filter_frequency = 0;
end
if notch_filter_frequency > 0
    % Explicit is better than implicit; let the user decide
    % whether to reapply the notch filter
    warning(['Software notch filter was used during recording, ' ...
        'but will not be reapplied automatically during load. ' ...
        'Instead see the notch filter function handle included ' ...
        'in the header if reapplying it is desired.']);
    hdr.notch_function = @(x)notch_filter(x, sample_rate, ...
        notch_filter_frequency, 10);
else
    hdr.notch_function = @(x)x;
end

% Read channel header info
% Channel headers are organized into "groups" corresponding to the port
% the channel is associated with. We'll load all the channel info and then
% separate them by signal type.
number_of_groups = fread(fid, 1, 'int16');
channel_headers = cell(number_of_groups,1);

for group_ind = 1:number_of_groups
    group = read_structured(struct, {
        'name', 'qstring';
        'prefix', 'qstring';
        'enabled', 'int16';
        'num_channels', 'int16';
        'num_amp_channels', 'int16'; % This is not actually used it seems
    });
    if group.enabled && group.num_channels > 0
        group_channels = cell(group.num_channels, 1);
        group_template = struct;
        group_template.port_name = group.name;
        group_template.port_prefix = group.prefix;
        group_template.port_number = group_ind;
        for ch = 1:group.num_channels
            new_channel = read_structured(group_template, {
                    'native_channel_name', 'qstring';
                    'custom_channel_name', 'qstring';
                    'native_order', 'int16';
                    'custom_order', 'int16';
                    'signal_type', 'int16';
                    'enabled', 'int16';
                    'chip_channel', 'int16';
                    'board_stream', 'int16';
                    'voltage_trigger_mode', 'int16';
                    'voltage_threshold', 'int16';
                    'digital_trigger_channel', 'int16';
                    'digital_edge_polarity', 'int16';
                    'electrode_impedance_magnitude', 'single';
                    'electrode_impedance_phase', 'single';
                });
            if new_channel.enabled
                group_channels{ch} = new_channel;
            end
            % If the channel isn't enabled, we just discard the info
        end
        channel_headers{group_ind} = safe_vertcat(group_channels{:});
    end
end
channel_headers = safe_vertcat(channel_headers{:});

signal_type_codes = {
    0, 'amplifier';
    1, 'aux_input';
    2, 'supply_voltage';
    3, 'board_adc';
    4, 'board_dig_in';
    5, 'board_dig_out';
    };

if hdr.file_version(1) == 1
    block_sample_count = 60;
else
    block_sample_count = 128;
end

if version_is_at_least(hdr.file_version, [1 2])
    ts_type = 'int32';
else
    ts_type = 'uint32';
end

switch hdr.eval_board_mode
    case 1
        adc_converter = @(y) 152.59e-6 * (y - 32768);
    case 13
        adc_converter = @(y) 312.5e-6 * (y - 32768);
    otherwise
        adc_converter = @(y) 50.354e-6 * y;
end

bs = block_sample_count;
% Presented in this form for readability
signal_info_table = {
    %                 sampling
    % signal           divisor
    %  name        code   :  datatype  units   converter function
    'timestamp',    NaN,  1, ts_type,  's',    @(t) t / sample_rate;
    'amplifier',      0,  1, 'uint16', 'uV',   @(y) 0.195 * (y-32768);
    'aux_input',      1,  4, 'uint16', 'V',    @(y) 37.4e-6 * y;
    'supply_voltage', 2, bs, 'uint16', 'V',    @(y) 74.8e-6 * y;
    'temp_sensor',  NaN, bs, 'int16',  'degC', @(y) y / 100;
    'board_adc',      3,  1, 'uint16', 'V',    adc_converter;
    'board_dig_in',   4,  1, 'uint16', '',     @(y) y;
    'board_dig_out',  5,  1, 'uint16', '',     @(y) y;
};

signal_fields = {'name', 'code', 'divisor', 'datatype', 'units', ...
    'converter', 'headers', 'data', 'num_raw_channels', 'samples_per_block'};
signal_info_table(:,(end+1):numel(signal_fields)) = {[]};
signals = cell2struct(signal_info_table, signal_fields, 2);

bytes_per_block = 0;
for i=1:numel(signals)
    channel_is_this_type = [channel_headers.signal_type] == signals(i).code;
    signals(i).headers = channel_headers(channel_is_this_type);
    
    % Get the number of channels associated with each signal type
    switch signals(i).name
        case 'timestamp'
            % Always one timestamp "channel"
            num_channels = 1;
        case 'temp_sensor'
            % Number of these is given in the main section of the header
            num_channels = hdr.num_temp_sensor_channels;
        case {'board_dig_in', 'board_dig_out'}
            % These are bit fields, so one "channel" if any exist,
            % otherwise none.
            num_channels = double(numel(signals(i).headers) > 0);
        otherwise
            % All other cases, just count the number of channels from
            % the header.
            num_channels = numel(signals(i).headers);
    end
    signals(i).num_raw_channels = num_channels;
    
    samples_per_block = num_channels * ...
        block_sample_count / signals(i).divisor;
    signals(i).samples_per_block = samples_per_block;
    
    switch signals(i).datatype
        case {'int32', 'uint32'}
            bytes_per_sample = 4;
        case {'int16', 'uint16'}
            bytes_per_sample = 2;
        otherwise
            error('Unrecognized data type!');
    end
    bytes_per_block = bytes_per_block + samples_per_block * bytes_per_sample;
end

file_info = stat(fid);
bytes_remaining = file_info.size - ftell(fid);
num_blocks = bytes_remaining / bytes_per_block;

% Preallocate data for all signals
for i=1:numel(signals)
    signals(i).data = zeros( ...
        signals(i).num_raw_channels, ...
        signals(i).samples_per_block, ...
        num_blocks );
end

% Load all data from file
for i=1:num_blocks
    for j=1:numel(signals)
        signals(j).data(:,:,i) = fread( fid, ...
            [size(signals(j).data, 2), size(signals(j).data, 1)], ...
            signals(j).datatype )';
    end
end

fclose(fid);

% Clean up the data into usable form
for i=1:numel(signals)
    % Collapse dimension 3 (block number) into dimension 2 (time)
    signals(i).data = reshape( ...
        signals(i).data, ...
        signals(i).num_raw_channels, ...
        [] );
    
    % A couple of special cases
    switch signals(i).name
        case 'timestamp'
            % Check for gaps in the data
            if any(diff(signals(i).data ~= 1))
                warning('Note: gaps in timestamp data detected.')
            end
        case {'board_dig_in', 'board_dig_out'}
            % Convert from bit field vector to logical array
            native_order = [signals(i).headers.native_order];
            signals(i).data = bitfield_to_logical_array( ...
                signals(i).data, native_order );
    end
    
    % Convert data to true values
    signals(i).data = signals(i).converter(signals(i).data);
end

dat = struct;
dat.header = hdr;
dat.signals = signals;

end

% Fixes for Octave bugs
function x = safe_vertcat(varargin)
empty_inputs = cellfun(@isempty, varargin);
x = vertcat(varargin{empty_inputs});
end

function x = safe_horzcat(varargin)
empty_inputs = cellfun(@isempty, varargin);
x = horzcat(varargin{empty_inputs});
end

function tf = version_is_at_least(version, testversion)
tf = version(1) > testversion(1) || ...
    (version(1) == testversion(1) && version(2) >= testversion(2));

end

function a = fread_QString(fid)
% This function copied from the original Intan file
% a = read_QString(fid)
%
% Read Qt style QString.  The first 32-bit unsigned number indicates
% the length of the string (in bytes).  If this number equals 0xFFFFFFFF,
% the string is null.

a = '';
length = fread(fid, 1, 'uint32');
if length == hex2num('ffffffff')
    return;
end
% convert length from bytes to 16-bit Unicode words
length = length / 2;

for i=1:length
    a(i) = fread(fid, 1, 'uint16');
end

end

function tf = bitfield_to_logical_array(bitfield, bits)
% Convert a vector of bitfield values to a logical array

n = numel(bitfield);
tf = false(numel(bits), n);
for i = 1:numel(bits)
    mask = 2^(bits(i)) * ones(1,n);
    tf(i,:) = logical(bitand(bitfield, mask));
end

end

function out = notch_filter(in, fSample, fNotch, Bandwidth)
% This function taken from the read_Intan_RHD2000_file.m code
% out = notch_filter(in, fSample, fNotch, Bandwidth)
%
% Implements a notch filter (e.g., for 50 or 60 Hz) on vector 'in'.
% fSample = sample rate of data (in Hz or Samples/sec)
% fNotch = filter notch frequency (in Hz)
% Bandwidth = notch 3-dB bandwidth (in Hz).  A bandwidth of 10 Hz is
%   recommended for 50 or 60 Hz notch filters; narrower bandwidths lead to
%   poor time-domain properties with an extended ringing response to
%   transient disturbances.
%
% Example:  If neural data was sampled at 30 kSamples/sec
% and you wish to implement a 60 Hz notch filter:
%
% out = notch_filter(in, 30000, 60, 10);

tstep = 1/fSample;
Fc = fNotch*tstep;

L = length(in);

% Calculate IIR filter parameters
d = exp(-2*pi*(Bandwidth/2)*tstep);
b = (1 + d*d)*cos(2*pi*Fc);
a0 = 1;
a1 = -b;
a2 = d*d;
a = (1 + d*d)/2;
b0 = 1;
b1 = -2*cos(2*pi*Fc);
b2 = 1;

out = zeros(size(in));
out(1) = in(1);  
out(2) = in(2);
% (If filtering a continuous data stream, change out(1) and out(2) to the
%  previous final two values of out.)

% Run filter
for i=3:L
    out(i) = (a*b2*in(i-2) + a*b1*in(i-1) + a*b0*in(i) - a2*out(i-2) - a1*out(i-1))/a0;
end

end
